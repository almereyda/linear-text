import type {FileWithHandle} from 'browser-fs-access'
import type {LineIndex} from '../../table/line-index'
import type {RootState} from '../store'

import {createAsyncThunk, createSlice, PayloadAction} from '@reduxjs/toolkit'
import {IDFactory} from '../../id/id-factory'
import {Line} from '../../line/line'
import {NonNull} from '../../utils/assert'
import {parseTable} from '../../table-parser/table-parser'
import {Table} from '../../table/table'

export type TableState = Readonly<{
  /** The loaded / saved filename, if any. */
  filename: string | undefined
  /** undefined or [0, table.lines.length). */
  focus: LineIndex | undefined
  idFactory: Readonly<IDFactory>
  /**
   * True if unsaved changes are present. False if no changes since saved, just
   * loaded and unchanged, or new and unchanged.
   */
  invalidated: boolean
  status: 'idle' | 'loading' | 'failed'
  table: Readonly<Table>
}>

export const initTableState: TableState = Object.freeze({
  filename: undefined,
  focus: undefined,
  idFactory: Object.freeze(IDFactory()),
  invalidated: false,
  status: 'idle',
  table: Object.freeze(Table())
})

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const loadTableFileAsync = createAsyncThunk<
  {filename: string; idFactory: Readonly<IDFactory>; table: Table},
  {fileWithHandle: Readonly<FileWithHandle>; idFactory: Readonly<IDFactory>},
  {state: RootState}
>('table/loadTableFileAsync', async ({fileWithHandle, idFactory}) => {
  // The value we return becomes the `fulfilled` action payload
  const factory = IDFactory(idFactory)
  const table = await parseTable(factory, fileWithHandle)
  return {filename: fileWithHandle.name, idFactory: factory, table}
})

export const tableSlice = createSlice({
  name: 'table',
  initialState: initTableState,
  // The `reducers` field lets us define reducers and generate associated
  // actions.
  reducers: {
    // Redux Toolkit allows us to write "mutating" logic in reducers. It
    // doesn't actually mutate the state because it uses the Immer library,
    // which detects changes to a "draft state" and produces a brand new
    // immutable state based off those changes
    // Use the PayloadAction type to declare the contents of `action.payload`
    addDividerAction(state) {
      const line = Line(state.idFactory)
      const index =
        state.focus == null ? state.table.lines.length : state.focus.x + 1
      state.table.lines.splice(index, 0, line)
      state.focus = {id: line.id, x: index}
    },
    addDraftAction(state) {
      const focus =
        state.focus == null ? undefined : state.table.lines[state.focus?.x]
      if (focus?.state === 'draft') return // Already have a draft.
      const line = Line(state.idFactory, true)
      const index =
        state.focus == null ? state.table.lines.length : state.focus.x + 1
      state.table.lines.splice(index, 0, line)
      state.focus = {id: line.id, x: index}
    },
    editLineAction(
      state,
      {payload}: PayloadAction<{index: LineIndex; text: string}>
    ) {
      const line = NonNull(state.table.lines[payload.index.x])
      Line.setText(line, payload.text)
      // The state of line is changed. It is assumed to be the focus.
      state.focus = payload.index
      state.invalidated = true
    },
    focusLineAction(state, {payload}: PayloadAction<LineIndex | undefined>) {
      state.focus = payload
    },
    newFileAction(state) {
      state.filename = undefined
      state.focus = undefined
      state.invalidated = false
      state.status = 'idle'
      state.table = Table()
      // [todo]: cancel loading.
    },
    removeLineAction(
      state,
      {
        payload
      }: PayloadAction<{
        index: LineIndex
        nextFocus: 'prev' | 'next' | 'retain'
      }>
    ) {
      Table.removeLine(state.table, payload.index.id)
      state.invalidated = true
      if (payload.nextFocus === 'retain') {
        state.focus =
          state.focus?.id === payload.index.id ? undefined : state.focus
      } else {
        const nextIndex = Math.max(
          0,
          Math.min(
            payload.index.x + (payload.nextFocus === 'prev' ? -1 : 0),
            state.table.lines.length - 1
          )
        )
        const nextLine = state.table.lines[nextIndex]
        state.focus =
          nextLine == null ? undefined : {id: nextLine.id, x: nextIndex}
      }
    },
    saveFileAction(state, {payload}: PayloadAction<string | undefined>) {
      state.filename = payload
      state.invalidated = false
    }
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers(builder) {
    builder
      .addCase(loadTableFileAsync.pending, state => {
        state.status = 'loading'
      })
      .addCase(loadTableFileAsync.fulfilled, (state, {payload}) => {
        state.invalidated = false
        state.filename = payload.filename
        state.idFactory = payload.idFactory
        state.table = payload.table
        state.focus = undefined
        state.status = 'idle'
      })
      .addCase(loadTableFileAsync.rejected, state => {
        state.status = 'failed'
        // [todo]: show errors.
      })
  }
})

export const {
  addDividerAction,
  addDraftAction,
  editLineAction,
  focusLineAction,
  newFileAction,
  removeLineAction,
  saveFileAction
} = tableSlice.actions

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example:
// `useSelector((state: RootState) => state.table.value)`.
export function selectTableState(state: RootState): TableState {
  return state.table.present
}
